---
# These are optional elements. Feel free to remove any of them.
status: accepted
contact: rogerbarreto
date: 2023-05-29
deciders: @rogerbarreto, @shawncal, @stephentoub
consulted: 
informed: 
---

# Kernel/Function Handlers

## Context and Problem Statement

A Kernel function caller needs to be able to handle/intercept any function execution in the Kernel before and after it was attempted. Allowing it to modify the prompt, abort the execution, or modify the output and many other scenarios as follows:

- Pre-Execution / Running

  - Get: Original prompt template
  - Get: Prompt generated by the current Kernel `TemplateEngine` before calling the LLM
  - Get: Current settings used
  - Get: Parameters used
  - Get: SKContext
  - Set: Modify a prompt content before sending it to LLM
  - Set: Abort/Cancel function execution

- In-Execution / Stream Processing

  - Get: Text Prompt generated per stream block `IAsyncEnumerable<string>`
  - Set: Filter/Change a prompt stream block
  - Set: Skip a prompt stream block

- Post-Execution / Ran

  - Get: LLM Model Result (Tokens Usage, Stop Sequence, ...)
  - Get: Generated Prompt
  - Get: SKContext
  - Get: Output parameters

  - Set: Modify a prompt content after getting it from LLM
  - Set: Modify output parameters content (before returning the output)

## Decision Drivers

- Architecture changes and the associated decision making process should be transparent to the community.
- Decision records are stored in the repository and are easily discoverable for teams involved in the various language ports.

## Considered Options

- Callback Registration + Recursive
- Single Callback
- Event Based Registration
- Middleware

## Pros and Cons of the Options

### Callback Registration Recursive Delegate (Kernel, Plan, Function)

- Specified on plan and function level as a configuration be able to specify what are the callback Handlers that will be triggered.

Pros:

- Common pattern for observing and also changing data exposed as parameter into the delegate signature for (Get/Set) scenarios
- Registering a callback gives back the registration object that can be used to cancel the execution of the function in the future.
- Recursive approach, allows to register multiple callbacks for the same event, and also allows to register callbacks on top of pre existing callbacks.

Cons:

- Registrations may use more memory and might not be garbage collected in the recursive approach, only when the function or the plan is disposed.

### Single Callback Delegate (Kernel, Plan, Function)

- Specified on kernel level as a configuration be able to specify what are the callback Handlers that will be triggered.
  - Specified on function creation: As part of the function constructor be able to specify what are the callback Handlers that will be triggered.
  - Specified on function invocation: As part of the function invoke be able to specify what are the callback Handlers as a parameter that will be triggered.

Pros:

- Common pattern for observing and also changing data exposed as parameter into the delegate signature for (Get/Set) scenarios

Cons:

- Limited to only one method observing a specific event (Pre Post and InExecution). - Function When used as parameter, three new parameters would be needed as part of the function. (Specified on function invocation) - Extra Cons on

### Event Base Registration (Kernel only)

Expose events on both IKernel and ISKFunction that the call can can be observing to interact.

Pros:

- Multiple Listeners can registered for the same event
- Listeners can be registered and unregistered at will
- Common pattern (EventArgs) for observing and also changing data exposed as parameter into the event signature for (Get/Set) scenarios

Cons:

- Event handlers are void, making the EventArgs by reference the only way to modify the data.
- Not clear how supportive is this approach for asynchronous pattern/multi threading
- Won't support `ISKFunction.InvokeAsync`

### Middleware (Kernel Only)

Specified on Kernel level, and would only be used using IKernel.RunAsync operation, this pattern would be similar to asp.net core middlewares, running the pipelines with a context and a requestdelegate next for controlling (Pre/Post conditions)

Pros:

- Common pattern for handling Pre/Post Setting/Filtering data

Cons:

- Functions can run on their own instance, middlewares suggest more complexity and the existence of an external container/manager (Kernel) to intercept/observe function calls.

## Main Questions

- Q: Post Execution Handlers should execute right after the LLM result or before the end of the function execution itself?
  A: Currently post execution Handlers are executed after function execution.

- Q: Should Pre/Post Handlers be many (pub/sub) allowing registration/deregistration?
  A: By using the standard .NET event implementation, this already supports multiple registrations as well as deregistrations managed by the caller.

- Q: Setting Handlers on top of pre existing Handlers should be allowed or throw an error?
  A: By using the standard .NET event implementation, the stander behavior will not throw an error and will execute all the registered handlers.

- Q: Setting Handlers on Plans should automatically cascade this Handlers for all the inner steps + overriding existing ones in the process?
  A: Handlers will be triggered before and after each step is executed the same way the Kernel RunAsync pipeline works.

- Q: When a pre execution handler cancel the execution of the function,

- Q: When a pre function execution handler intents to cancel the execution, should further handlers in the chain be called or not?
  A: Currently the standard .net behavior is to call all the registered handlers. This way function execution will solely depends on the final boolean state of the Cancel property after all handlers were called.

## Decision Outcome

TBD.
