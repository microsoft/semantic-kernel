// Copyright (c) Microsoft. All rights reserved.

using System;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.SemanticKernel.Memory;
using Microsoft.SemanticKernel.Memory.Storage;
using Qdrant.DotNet;
using Qdrant.DotNet.Internal.Diagnostics;

namespace Microsoft.SemanticKernel.Skills.Memory.VectorDB;

/// <summary>
/// /// An implementation of <see cref="IDataStore{TValue}"/> backed by a Qdrant Vector database.
/// </summary>
/// <remarks>The vector data is saved to Qdrant Vector Database run locally or in cloud, specified in the constructor.
/// The data persists between subsequent instances. </remarks>
/// <typeparam name="TValue">The type of data to be stored in this data store.</typeparam>
public class QdrantDataStore<TValue> : IDataStore<TValue>
{
    /// <summary>
    /// Connect a Qdrant Vector database
    /// </summary>
    /// <param name="endpoint">IP Address or URL endpoint to Qdrant Vectore Database.</param>
    /// <param name="port">Port to be used for Qdrant Vector DB</param>
    public static QdrantDataStore<TValue> ConnectVectorDB(string endpoint, int port)
    {
        QdrantDb vectorDBConnection = QdrantVectorDB.CreateVectorDBConnection(endpoint, port);
        return new QdrantDataStore<QdrantDb>(vectorDBConnection);
    }

 /// <inheritdoc/>
    public IAsyncEnumerable<string> GetContainersAsync()
    {
        //Go get all collection in DB of them everytime
        return this._qdrantstore.Keys.ToAsyncEnumerable();
    }

    /// <inheritdoc/>
    public IAsyncEnumerable<DataEntry<TValue>> GetAllAsync(string container, CancellationToken cancel = default)
    {

        IVectorDbCollection vdbCollection = this._qdrantstore.GetOrNull(container);
        if (vdbCollection != null) {return vdbCollection; }
    
        try
        {
            vdbCollection = await this._qdrantdbClient.GetCollection(container);
            this._qdrantstore.AddOrUpdate(container, vdbCollection);
        }
        catch(VectorDBException ex)
        {
            throw new VectorDbException($"Error while getting collection {container} from Qdrant Vector DB", ex);
        }
       
    }

    /// <inheritdoc/>
    public Task<DataEntry<TValue>?> GetAsync(string container, string key, CancellationToken cancel = default)
    {
        IVectorDbCollection vdbCollection = this._qdrantstore.GetOrNull(container);

        return Task.FromResult<DataEntry<TValue>?>(null);
    }

    /// <inheritdoc/>
    Task<DataEntry<TValue>> PutAsync(string container, DataEntry<TValue> data, CancellationToken cancel = default){}

    /// <inheritdoc/>
    Task RemoveAsync(string container, string key, CancellationToken cancel = default);

    #region private ================================================================================

    private readonly QdrantDb _qdrantdbClient;
    private readonly ConcurrentDictionary<string, IVectorDbCollection> _qdrantstore = new();

    /// <summary>
    /// Constructor
    /// </summary>
    /// <param name="qdrantdbClient">Qdrant VectorDB Client</param>
    private QdrantDataStore(QdrantDb qdrantdbClient)
    {
        this._qdrantdbClient = qdrantdbClient;
    }
    
    private static string? ValueToString(TValue? value)
    {
        if (value != null)
        {
            if (typeof(TValue) == typeof(string))
            {
                return value.ToString();
            }

            return JsonSerializer.Serialize(value);
        }

        return null;
    }

    private static string? ToTimestampString(DateTimeOffset? timestamp)
    {
        return timestamp?.ToString("u", CultureInfo.InvariantCulture);
    }

    private static DateTimeOffset? ParseTimestamp(string? str)
    {
        if (!string.IsNullOrEmpty(str)
            && DateTimeOffset.TryParse(str, CultureInfo.InvariantCulture, DateTimeStyles.AssumeUniversal, out DateTimeOffset timestamp))
        {
            return timestamp;
        }

        return null;
    }

    #endregion
    
}





