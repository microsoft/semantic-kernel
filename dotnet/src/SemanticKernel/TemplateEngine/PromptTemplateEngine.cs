// Copyright (c) Microsoft. All rights reserved.

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using Microsoft.SemanticKernel.Orchestration;
using Microsoft.SemanticKernel.TemplateEngine.Blocks;

namespace Microsoft.SemanticKernel.TemplateEngine;

/// <summary>
/// Given a prompt, that might contain references to variables and functions:
/// - Get the list of references
/// - Resolve each reference
///   - Variable references are resolved using the context variables
///   - Function references are resolved invoking those functions
///     - Functions can be invoked passing in variables
///     - Functions do not receive the context variables, unless specified using a special variable
///     - Functions can be invoked in order and in parallel so the context variables must be immutable when invoked within the template
/// </summary>
public class PromptTemplateEngine : IPromptTemplateEngine
{
    public PromptTemplateEngine(ILogger? log = null)
    {
        this._log = log ?? NullLogger.Instance;
    }

    /// <summary>
    /// Given a prompt template string, extract all the blocks (text, variables, function calls)
    /// </summary>
    /// <param name="templateText">Prompt template (see skprompt.txt files)</param>
    /// <param name="validate">Whether to validate the blocks syntax, or just return the blocks found, which could contain invalid code</param>
    /// <returns>A list of all the blocks, ie the template tokenized in text, variables and function calls</returns>
    public IList<Block> ExtractBlocks(string? templateText, bool validate = true)
    {
        this._log.LogTrace("Extracting blocks from template: {0}", templateText);
        var blocks = this.TokenizeInternal(templateText);
        if (validate) { ValidateBlocksSyntax(blocks); }

        return blocks;
    }

    /// <summary>
    /// Given a prompt template, replace the variables with their values and execute the functions replacing their
    /// reference with the function result.
    /// </summary>
    /// <param name="templateText">Prompt template (see skprompt.txt files)</param>
    /// <param name="executionContext">Access into the current kernel execution context</param>
    /// <returns>The prompt template ready to be used for an AI request</returns>
    public async Task<string> RenderAsync(
        string templateText,
        SKContext executionContext)
    {
        this._log.LogTrace("Rendering string template: {0}", templateText);
        var blocks = this.ExtractBlocks(templateText);
        return await this.RenderAsync(blocks, executionContext);
    }

    /// <summary>
    /// Given a a list of blocks render each block and compose the final result
    /// </summary>
    /// <param name="blocks">Template blocks generated by ExtractBlocks</param>
    /// <param name="executionContext">Access into the current kernel execution context</param>
    /// <returns>The prompt template ready to be used for an AI request</returns>
    public async Task<string> RenderAsync(
        IList<Block> blocks,
        SKContext executionContext)
    {
        this._log.LogTrace("Rendering list of {0} blocks", blocks.Count);
        var result = new StringBuilder();
        foreach (var block in blocks)
        {
            switch (block.Type)
            {
                case BlockTypes.Text:
                    result.Append(block.Content);
                    break;

                case BlockTypes.Variable:
                    result.Append(block.Render(executionContext.Variables));
                    break;

                case BlockTypes.Code:
                    result.Append(await block.RenderCodeAsync(executionContext));
                    break;

                case BlockTypes.Undefined:
                default:
                    throw new InvalidEnumArgumentException(nameof(blocks), (int)block.Type, typeof(BlockTypes));
            }
        }

        this._log.LogDebug("Rendered prompt: {0}", result);
        return result.ToString();
    }

    /// <summary>
    /// Given a list of blocks, render the Variable Blocks, replacing placeholders with the actual value in memory
    /// </summary>
    /// <param name="blocks">List of blocks, typically all the blocks found in a template</param>
    /// <param name="variables">Container of all the temporary variables known to the kernel</param>
    /// <returns>An updated list of blocks where Variable Blocks have rendered to Text Blocks</returns>
    public IList<Block> RenderVariables(IList<Block> blocks, ContextVariables? variables)
    {
        this._log.LogTrace("Rendering variables");
        return blocks.Select(block => block.Type != BlockTypes.Variable
            ? block
            : new TextBlock(block.Render(variables), this._log)).ToList();
    }

    /// <summary>
    /// Given a list of blocks, render the Code Blocks, executing the functions and replacing placeholders with the functions result
    /// </summary>
    /// <param name="blocks">List of blocks, typically all the blocks found in a template</param>
    /// <param name="executionContext">Access into the current kernel execution context</param>
    /// <returns>An updated list of blocks where Code Blocks have rendered to Text Blocks</returns>
    public async Task<IList<Block>> RenderCodeAsync(
        IList<Block> blocks,
        SKContext executionContext)
    {
        this._log.LogTrace("Rendering code");
        var updatedBlocks = new List<Block>();
        foreach (var block in blocks)
        {
            if (block.Type != BlockTypes.Code)
            {
                updatedBlocks.Add(block);
            }
            else
            {
                var codeResult = await block.RenderCodeAsync(executionContext);
                updatedBlocks.Add(new TextBlock(codeResult, this._log));
            }
        }

        return updatedBlocks;
    }

    #region private ================================================================================

    private readonly ILogger _log;

    // Blocks delimitation
    private const char Starter = '{';
    private const char Ender = '}';

    private IList<Block> TokenizeInternal(string? template)
    {
        // An empty block consists of 4 chars: "{{}}"
        const int EMPTY_CODE_BLOCK_LENGTH = 4;
        // A block shorter than 5 chars is either empty or invalid, e.g. "{{ }}" and "{{$}}"
        const int MIN_CODE_BLOCK_LENGTH = EMPTY_CODE_BLOCK_LENGTH + 1;

        // Render NULL to ""
        if (template == null)
        {
            return new List<Block> { new TextBlock("", this._log) };
        }

        // If the template is "empty" return the content as a text block
        if (template.Length < MIN_CODE_BLOCK_LENGTH)
        {
            return new List<Block> { new TextBlock(template, this._log) };
        }

        var blocks = new List<Block>();

        var cursor = 0;
        var endOfLastBlock = 0;

        var startPos = 0;
        var startFound = false;

        while (cursor < template.Length - 1)
        {
            // When "{{" is found
            if (template[cursor] == Starter && template[cursor + 1] == Starter)
            {
                startPos = cursor;
                startFound = true;
            }
            // When "}}" is found
            else if (startFound && template[cursor] == Ender && template[cursor + 1] == Ender)
            {
                // If there is plain text between the current var/code block and the previous one, capture that as a TextBlock
                if (startPos > endOfLastBlock)
                {
                    blocks.Add(new TextBlock(template, endOfLastBlock, startPos, this._log));
                }

                // Skip ahead to the second "}" of "}}"
                cursor++;

                // Extract raw block
                var contentWithDelimiters = SubStr(template, startPos, cursor + 1);

                // Remove "{{" and "}}" delimiters and trim empty chars
                var contentWithoutDelimiters = contentWithDelimiters
                    .Substring(2, contentWithDelimiters.Length - EMPTY_CODE_BLOCK_LENGTH).Trim();

                if (contentWithoutDelimiters.Length == 0)
                {
                    // If what is left is empty, consider the raw block a Text Block
                    blocks.Add(new TextBlock(contentWithDelimiters, this._log));
                }
                else
                {
                    // If the block starts with "$" it's a variable
                    if (VarBlock.HasVarPrefix(contentWithoutDelimiters))
                    {
                        // Note: validation is delayed to the time VarBlock is rendered
                        blocks.Add(new VarBlock(contentWithoutDelimiters, this._log));
                    }
                    else
                    {
                        // Note: validation is delayed to the time CodeBlock is rendered
                        blocks.Add(new CodeBlock(contentWithoutDelimiters, this._log));
                    }
                }

                endOfLastBlock = cursor + 1;
                startFound = false;
            }

            cursor++;
        }

        // If there is something left after the last block, capture it as a TextBlock
        if (endOfLastBlock < template.Length)
        {
            blocks.Add(new TextBlock(template, endOfLastBlock, template.Length, this._log));
        }

        return blocks;
    }

    private static string SubStr(string text, int startIndex, int stopIndex)
    {
        return text.Substring(startIndex, stopIndex - startIndex);
    }

    private static void ValidateBlocksSyntax(IList<Block> blocks)
    {
        foreach (var block in blocks)
        {
            if (!block.IsValid(out var error))
            {
                throw new TemplateException(TemplateException.ErrorCodes.SyntaxError, error);
            }
        }
    }

    #endregion
}
