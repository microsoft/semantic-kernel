# Copyright (c) Microsoft. All rights reserved.

from unittest.mock import AsyncMock, Mock, patch

import boto3
import pytest

from semantic_kernel.agents.bedrock.action_group_utils import parse_function_result_contents
from semantic_kernel.agents.bedrock.bedrock_agent import BedrockAgent
from semantic_kernel.connectors.ai.function_choice_behavior import FunctionChoiceBehavior
from semantic_kernel.contents.function_result_content import FunctionResultContent
from semantic_kernel.exceptions.agent_exceptions import AgentInitializationException, AgentInvokeException
from semantic_kernel.prompt_template.prompt_template_config import PromptTemplateConfig


# Test case to verify the initialization of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_initialization(client, bedrock_agent_unit_test_env):
    agent = BedrockAgent(name="test_agent", env_file_path="fake_path")

    assert agent.name == "test_agent"
    assert agent.agent_model.agent_name == "test_agent"
    assert agent.id is not None  # This is a UUID generated by the agent class
    assert agent.agent_model.agent_id is None  # The agent has not been created on the service yet
    assert agent.agent_resource_role_arn == bedrock_agent_unit_test_env["BEDROCK_AGENT_AGENT_RESOURCE_ROLE_ARN"]
    assert agent.agent_model.foundation_model == bedrock_agent_unit_test_env["BEDROCK_AGENT_FOUNDATION_MODEL"]


# Test case to verify error handling during BedrockAgent initialization
@pytest.mark.parametrize("exclude_list", [["BEDROCK_AGENT_AGENT_RESOURCE_ROLE_ARN"]], indirect=True)
async def test_bedrock_agent_initialization_error(bedrock_agent_unit_test_env):
    with pytest.raises(AgentInitializationException, match="Failed to initialize the Amazon Bedrock Agent settings."):
        BedrockAgent(name="test_agent", env_file_path="fake_path")


# Test case to verify error handling during BedrockAgent initialization with instructions and prompt template
async def test_bedrock_agent_initialization_error_with_instructions_and_prompt_template(bedrock_agent_unit_test_env):
    with pytest.raises(
        AgentInitializationException, match="Cannot set both instructions and prompt_template_config.template."
    ):
        BedrockAgent(
            name="test_agent",
            instructions="test_instructions",
            prompt_template_config=PromptTemplateConfig(template="test_template"),
            env_file_path="fake_path",
        )


# Test case to verify error handling during BedrockAgent initialization with non-auto function choice
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_initialization_error_with_non_auto_function_choice(client, bedrock_agent_unit_test_env):
    with pytest.raises(ValueError, match="Only FunctionChoiceType.AUTO is supported."):
        BedrockAgent(
            name="test_agent",
            function_choice_behavior=FunctionChoiceBehavior.NoneInvoke(),
            env_file_path="fake_path",
        )


# Test case to verify the creation of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_create(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id_not_prepared_dict,
):
    agent = BedrockAgent(name="test_agent", instructions="test_instructions", env_file_path="fake_path")

    assert agent.agent_model.agent_id is None

    with (
        patch.object(agent.bedrock_client, "create_agent") as mock_create_agent,
        patch.object(agent.bedrock_client, "get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "prepare_agent", new_callable=AsyncMock),
    ):
        mock_create_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict
        mock_get_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict

        await agent.create_agent()

        mock_create_agent.assert_called_once_with(
            agentName="test_agent",
            foundationModel=bedrock_agent_unit_test_env["BEDROCK_AGENT_FOUNDATION_MODEL"],
            agentResourceRoleArn=bedrock_agent_unit_test_env["BEDROCK_AGENT_AGENT_RESOURCE_ROLE_ARN"],
            instruction="test_instructions",
        )
        assert agent.agent_model.agent_id == bedrock_agent_model_with_id_not_prepared_dict["agent"]["agentId"]


# Test case to verify the creation of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_create_with_plugin_via_constructor(
    client, bedrock_agent_unit_test_env, bedrock_agent_model_with_id_not_prepared_dict, custom_plugin_class
):
    agent = BedrockAgent(
        name="test_agent", instructions="test_instructions", env_file_path="fake_path", plugins=[custom_plugin_class()]
    )

    assert agent.agent_model.agent_id is None

    with (
        patch.object(agent.bedrock_client, "create_agent") as mock_create_agent,
        patch.object(agent.bedrock_client, "get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "prepare_agent", new_callable=AsyncMock),
    ):
        mock_create_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict
        mock_get_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict

        await agent.create_agent()

        mock_create_agent.assert_called_once_with(
            agentName="test_agent",
            foundationModel=bedrock_agent_unit_test_env["BEDROCK_AGENT_FOUNDATION_MODEL"],
            agentResourceRoleArn=bedrock_agent_unit_test_env["BEDROCK_AGENT_AGENT_RESOURCE_ROLE_ARN"],
            instruction="test_instructions",
        )
        assert agent.agent_model.agent_id == bedrock_agent_model_with_id_not_prepared_dict["agent"]["agentId"]
        assert agent.kernel.plugins is not None
        assert len(agent.kernel.plugins) == 1


@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_create_existed(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id_not_prepared_dict,
):
    agent = BedrockAgent(name="test_agent", env_file_path="fake_path")

    assert agent.agent_model.agent_id is None

    with (
        patch.object(agent.bedrock_client, "create_agent") as mock_create_agent,
        patch.object(agent.bedrock_client, "get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "prepare_agent", new_callable=AsyncMock),
    ):
        mock_create_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict
        mock_get_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict

        await agent.create_agent()

        with pytest.raises(
            ValueError, match="Agent already exists. Please delete the agent before creating a new one."
        ):
            await agent.create_agent()


@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_create_with_options(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id_not_prepared_dict,
):
    agent = BedrockAgent(name="test_agent", env_file_path="fake_path")

    assert agent.agent_model.agent_id is None

    with (
        patch.object(agent.bedrock_client, "create_agent") as mock_create_agent,
        patch.object(agent.bedrock_client, "get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "prepare_agent", new_callable=AsyncMock),
        patch.object(
            BedrockAgent, "create_code_interpreter_action_group", new_callable=AsyncMock
        ) as mock_create_code_interpreter_action_group,
        patch.object(
            BedrockAgent, "create_user_input_action_group", new_callable=AsyncMock
        ) as mock_create_user_input_action_group,
        patch.object(
            BedrockAgent, "_create_kernel_function_action_group", new_callable=AsyncMock
        ) as mock_create_kernel_function_action_group,
    ):
        mock_create_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict
        mock_get_agent.return_value = bedrock_agent_model_with_id_not_prepared_dict

        await agent.create_agent(
            enable_code_interpreter=True,
            enable_user_input=True,
            enable_kernel_function=True,
        )

        mock_create_code_interpreter_action_group.assert_called_once()
        mock_create_user_input_action_group.assert_called_once()
        mock_create_kernel_function_action_group.assert_called_once()


# Test case to verify the retrieval of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_retrieve(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        mock_get_agent.assert_called_once()
        assert agent.agent_model.agent_id == bedrock_agent_model_with_id.agent_id
        assert agent.id == agent.agent_model.agent_id


# Test case to verify the `get_response` method of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_get_response(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_non_streaming_simple_response,
    simple_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        mock_invoke_agent.return_value = bedrock_agent_non_streaming_simple_response
        response = await agent.get_response("test_session_id", "test_input_text")
        assert response.content == simple_response

        mock_invoke_agent.assert_called_once_with(
            "test_session_id",
            "test_input_text",
            None,
            streamingConfigurations={"streamFinalResponse": False},
            sessionState={},
        )


# Test case to verify the `get_response` method of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_get_response_exception(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_non_streaming_empty_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        mock_invoke_agent.return_value = bedrock_agent_non_streaming_empty_response
        with pytest.raises(AgentInvokeException):
            await agent.get_response("test_session_id", "test_input_text")

            mock_invoke_agent.assert_called_once_with(
                "test_session_id",
                "test_input_text",
                None,
                streamingConfigurations={"streamFinalResponse": False},
                sessionState={},
            )


# Test case to verify the invocation of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_invoke(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_non_streaming_simple_response,
    simple_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        mock_invoke_agent.return_value = bedrock_agent_non_streaming_simple_response
        async for message in agent.invoke("test_session_id", "test_input_text"):
            assert message.content == simple_response

        mock_invoke_agent.assert_called_once_with(
            "test_session_id",
            "test_input_text",
            None,
            streamingConfigurations={"streamFinalResponse": False},
            sessionState={},
        )


# Test case to verify the streaming invocation of BedrockAgent
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_invoke_stream(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_streaming_simple_response,
    simple_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        mock_invoke_agent.return_value = bedrock_agent_streaming_simple_response
        full_message = ""
        async for message in agent.invoke_stream("test_session_id", "test_input_text"):
            full_message += message.content

        assert full_message == simple_response
        mock_invoke_agent.assert_called_once_with(
            "test_session_id",
            "test_input_text",
            None,
            streamingConfigurations={"streamFinalResponse": True},
            sessionState={},
        )


# Test case to verify the invocation of BedrockAgent with function call
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_invoke_with_function_call(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_function_call_response,
    bedrock_agent_non_streaming_simple_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
        patch.object(BedrockAgent, "_handle_function_call_contents") as mock_handle_function_call_contents,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        function_result_contents = [
            FunctionResultContent(
                id="test_id",
                name="test_function",
                result="test_result",
                metadata={"functionInvocationInput": {"actionGroup": "test_action_group"}},
            )
        ]
        mock_handle_function_call_contents.return_value = function_result_contents
        agent.function_choice_behavior.maximum_auto_invoke_attempts = 2

        mock_invoke_agent.side_effect = [
            bedrock_agent_function_call_response,
            bedrock_agent_non_streaming_simple_response,
        ]
        async for _ in agent.invoke("test_session_id", "test_input_text"):
            mock_invoke_agent.assert_called_with(
                "test_session_id",
                "test_input_text",
                None,
                streamingConfigurations={"streamFinalResponse": False},
                sessionState={
                    "invocationId": "test_invocation_id",
                    "returnControlInvocationResults": parse_function_result_contents(function_result_contents),
                },
            )


# Test case to verify the streaming invocation of BedrockAgent with function call
@patch.object(boto3, "client", return_value=Mock())
async def test_bedrock_agent_invoke_stream_with_function_call(
    client,
    bedrock_agent_unit_test_env,
    bedrock_agent_model_with_id,
    bedrock_agent_function_call_response,
    bedrock_agent_streaming_simple_response,
):
    with (
        patch.object(BedrockAgent, "_get_agent") as mock_get_agent,
        patch.object(BedrockAgent, "_invoke_agent", new_callable=AsyncMock) as mock_invoke_agent,
        patch.object(BedrockAgent, "_handle_function_call_contents") as mock_handle_function_call_contents,
    ):
        mock_get_agent.return_value = bedrock_agent_model_with_id

        agent = await BedrockAgent.retrieve(
            bedrock_agent_model_with_id.agent_id,
            bedrock_agent_model_with_id.agent_name,
            env_file_path="fake_path",
        )

        function_result_contents = [
            FunctionResultContent(
                id="test_id",
                name="test_function",
                result="test_result",
                metadata={"functionInvocationInput": {"actionGroup": "test_action_group"}},
            )
        ]
        mock_handle_function_call_contents.return_value = function_result_contents
        agent.function_choice_behavior.maximum_auto_invoke_attempts = 2

        mock_invoke_agent.side_effect = [
            bedrock_agent_function_call_response,
            bedrock_agent_streaming_simple_response,
        ]
        async for _ in agent.invoke_stream("test_session_id", "test_input_text"):
            mock_invoke_agent.assert_called_with(
                "test_session_id",
                "test_input_text",
                None,
                streamingConfigurations={"streamFinalResponse": True},
                sessionState={
                    "invocationId": "test_invocation_id",
                    "returnControlInvocationResults": parse_function_result_contents(function_result_contents),
                },
            )
