//! Math Plugin Example
//! 
//! This example demonstrates how to create a native plugin with functions
//! that can be called by the Semantic Kernel.

use semantic_kernel::{KernelBuilder, async_trait, kernel::{KernelPlugin, KernelFunction}};
use std::collections::HashMap;

// For now, creating manual implementations since the macro is still basic
// In the future, these would be generated by #[sk_plugin] and #[sk_function] macros

struct MathPlugin;

impl MathPlugin {
    /// Adds two numbers together
    pub async fn add(a: f64, b: f64) -> Result<f64, Box<dyn std::error::Error + Send + Sync>> {
        Ok(a + b)
    }
    
    /// Subtracts b from a
    pub async fn subtract(a: f64, b: f64) -> Result<f64, Box<dyn std::error::Error + Send + Sync>> {
        Ok(a - b)
    }
    
    /// Multiplies two numbers
    pub async fn multiply(a: f64, b: f64) -> Result<f64, Box<dyn std::error::Error + Send + Sync>> {
        Ok(a * b)
    }
    
    /// Divides a by b
    pub async fn divide(a: f64, b: f64) -> Result<f64, Box<dyn std::error::Error + Send + Sync>> {
        if b == 0.0 {
            return Err("Division by zero".into());
        }
        Ok(a / b)
    }
}

pub struct AddFunction;

#[async_trait]
impl KernelFunction for AddFunction {
    fn name(&self) -> &str {
        "add"
    }
    
    fn description(&self) -> &str {
        "Adds two numbers together"
    }
    
    async fn invoke(
        &self, 
        _kernel: &semantic_kernel::Kernel, 
        arguments: &HashMap<String, String>
    ) -> semantic_kernel::Result<String> {
        let a: f64 = arguments.get("a")
            .ok_or("Missing parameter 'a'")?
            .parse()
            .map_err(|_| "Invalid number for parameter 'a'")?;
            
        let b: f64 = arguments.get("b")
            .ok_or("Missing parameter 'b'")?
            .parse()
            .map_err(|_| "Invalid number for parameter 'b'")?;
            
        let result = MathPlugin::add(a, b).await?;
        Ok(result.to_string())
    }
}

pub struct SubtractFunction;

#[async_trait]
impl KernelFunction for SubtractFunction {
    fn name(&self) -> &str {
        "subtract"
    }
    
    fn description(&self) -> &str {
        "Subtracts b from a"
    }
    
    async fn invoke(
        &self, 
        _kernel: &semantic_kernel::Kernel, 
        arguments: &HashMap<String, String>
    ) -> semantic_kernel::Result<String> {
        let a: f64 = arguments.get("a")
            .ok_or("Missing parameter 'a'")?
            .parse()
            .map_err(|_| "Invalid number for parameter 'a'")?;
            
        let b: f64 = arguments.get("b")
            .ok_or("Missing parameter 'b'")?
            .parse()
            .map_err(|_| "Invalid number for parameter 'b'")?;
            
        let result = MathPlugin::subtract(a, b).await?;
        Ok(result.to_string())
    }
}

pub struct MathPluginImpl;

#[async_trait]
impl KernelPlugin for MathPluginImpl {
    fn name(&self) -> &str {
        "MathPlugin"
    }
    
    fn description(&self) -> &str {
        "Mathematical operations plugin"
    }
    
    fn functions(&self) -> Vec<&dyn KernelFunction> {
        vec![
            &AddFunction as &dyn KernelFunction,
            &SubtractFunction as &dyn KernelFunction,
        ]
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
    println!("🧮 Semantic Kernel Rust - Math Plugin Example");
    println!("==============================================");

    // Create a kernel with the math plugin
    let math_plugin = Box::new(MathPluginImpl);
    let kernel = KernelBuilder::new()
        .add_plugin("math", math_plugin)
        .build();

    // Test the add function through the plugin
    println!("\n➕ Testing Math Plugin Functions:");
    
    let mut args = HashMap::new();
    args.insert("a".to_string(), "10.5".to_string());
    args.insert("b".to_string(), "5.25".to_string());
    
    if let Some(plugin) = kernel.get_plugin("math") {
        let functions = plugin.functions();
        
        // Test add function
        if let Some(add_function) = functions.iter().find(|f| f.name() == "add") {
            let result = add_function.invoke(&kernel, &args).await?;
            println!("add(10.5, 5.25) = {}", result);
            
            // Show JSON schema for function calling
            let schema = add_function.get_json_schema();
            println!("JSON Schema: {}", serde_json::to_string_pretty(&schema)?);
        }
        
        // Test subtract function
        args.insert("a".to_string(), "100.0".to_string());
        args.insert("b".to_string(), "30.0".to_string());
        if let Some(subtract_function) = functions.iter().find(|f| f.name() == "subtract") {
            let result = subtract_function.invoke(&kernel, &args).await?;
            println!("subtract(100.0, 30.0) = {}", result);
        }
    }

    // Test direct function calls
    println!("\n🔢 Direct Function Calls:");
    let result1 = MathPlugin::add(15.0, 25.0).await?;
    println!("add(15.0, 25.0) = {}", result1);
    
    let result2 = MathPlugin::subtract(100.0, 30.0).await?;
    println!("subtract(100.0, 30.0) = {}", result2);
    
    let result3 = MathPlugin::multiply(7.0, 8.0).await?;
    println!("multiply(7.0, 8.0) = {}", result3);
    
    let result4 = MathPlugin::divide(50.0, 10.0).await?;
    println!("divide(50.0, 10.0) = {}", result4);

    // Test error handling
    println!("\n⚠️ Error Handling:");
    match MathPlugin::divide(10.0, 0.0).await {
        Ok(result) => println!("divide(10.0, 0.0) = {}", result),
        Err(e) => println!("divide(10.0, 0.0) failed: {}", e),
    }

    println!("\n✅ Math Plugin example completed successfully!");
    Ok(())
}